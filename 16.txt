前情回顾

1.线程  
  
  同步互斥 ： 利用阻塞 解决了共享资源争夺问题
  
  Lock()  lock.acquire()  lock.release()  
  Event()  wait()   set()  clear()
  
  
  死锁 ： 逻辑问题产生多个线程都无法执行
  
2. GIL （全局解释器锁）
    
	后果： 解释器同一时刻只能解释一个线程，执行非阻塞任务时效率低下。
	
	使用：多用于有高阻塞，多延迟的程序中


3. 进程线程的对比


FTP文件服务

1. 需求分析

   一对多模型
   客户端启动即可以连接服务器实现功能

2. 技术点分析

    网络 : Tcp
    并发 : 多进程或者多线程

3. 功能模块划分和封装

    查看文件库文件
    上传文件
    下载文件

    类封装


4. 通信协议设计

   几类请求?

              请求类型  数据量

    查看文件    LIST

    上传       PUT     文件名

    下载       GET     文件名

    退出       EXIT



5. 具体模块逻辑设计

    搭建并发网络模型 (完成)
    查看文件库文件 (设计逻辑功)
       客户端: 1. 发送请求
              2. 等待反馈结果
              3. 根据结果讨论
                  Yes : 接受文件列表
                  No : 结束

       服务端: 1. 接受请求,调用方法处理
              2. 判断能否发送文件列表
              3. Yes --> 给出反馈,发送文件列表
                 No  --> 给出反馈

    上传文件
        客户端:  1. 选择要上传的文件
                2. 发送请求
                3. 等待反馈
                4. Yes  发送文件
                   No   结束

        服务端:  1. 接受请求,判断文件是否存在
                2. 存在--> 不允许上传
                   不存在--> 可以上传
                3. 不存在 接受文件


    下载文件

cookie : 请求应答模式

请求从客户端发出 ---> 可能得到不同的结果
客户端处理 --> 根据不同的反馈可能有不同的处理方案

作业 : 1. 重点代码
      2. 思考 : 创建一个功能性的类 ,思考流程







